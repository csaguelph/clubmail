import { env } from "@/env";
import { SESClient, SendEmailCommand, SendRawEmailCommand } from "@aws-sdk/client-ses";

/**
 * AWS SES Email Service
 * 
 * This service handles all email sending operations using AWS SES.
 */

// Initialize SES client
const getSESClient = () => {
  if (!env.AWS_SES_REGION || !env.AWS_SES_ACCESS_KEY_ID || !env.AWS_SES_SECRET_ACCESS_KEY) {
    throw new Error("AWS SES credentials not configured");
  }

  return new SESClient({
    region: env.AWS_SES_REGION,
    credentials: {
      accessKeyId: env.AWS_SES_ACCESS_KEY_ID,
      secretAccessKey: env.AWS_SES_SECRET_ACCESS_KEY,
    },
  });
};

interface SendEmailParams {
  to: string;
  from: string;
  fromName?: string;
  replyTo?: string;
  subject: string;
  html: string;
  text?: string;
  unsubscribeUrl?: string;
}

/**
 * Send a single email via AWS SES
 */
export async function sendEmail(params: SendEmailParams): Promise<{
  success: boolean;
  messageId?: string;
  error?: string;
}> {
  try {
    const sesClient = getSESClient();
    
    const fromAddress = params.fromName 
      ? `${params.fromName} <${params.from}>`
      : params.from;

    // If we have an unsubscribe URL, use SendRawEmailCommand to include custom headers
    if (params.unsubscribeUrl) {
      // Build raw email with List-Unsubscribe headers
      const rawMessage = [
        `From: ${fromAddress}`,
        `To: ${params.to}`,
        ...(params.replyTo ? [`Reply-To: ${params.replyTo}`] : []),
        `Subject: ${params.subject}`,
        `MIME-Version: 1.0`,
        `Content-Type: text/html; charset=UTF-8`,
        `List-Unsubscribe: <${params.unsubscribeUrl}>`,
        `List-Unsubscribe-Post: List-Unsubscribe=One-Click`,
        ``,
        params.html,
      ].join("\r\n");

      const command = new SendRawEmailCommand({
        RawMessage: {
          Data: Buffer.from(rawMessage),
        },
      });

      const response = await sesClient.send(command);
      
      return {
        success: true,
        messageId: response.MessageId,
      };
    }

    // Otherwise use the simpler SendEmailCommand
    const command = new SendEmailCommand({
      Source: fromAddress,
      Destination: {
        ToAddresses: [params.to],
      },
      Message: {
        Subject: {
          Data: params.subject,
          Charset: "UTF-8",
        },
        Body: {
          Html: {
            Data: params.html,
            Charset: "UTF-8",
          },
          ...(params.text && {
            Text: {
              Data: params.text,
              Charset: "UTF-8",
            },
          }),
        },
      },
      ...(params.replyTo && {
        ReplyToAddresses: [params.replyTo],
      }),
    });

    const response = await sesClient.send(command);
    
    return {
      success: true,
      messageId: response.MessageId,
    };
  } catch (error) {
    console.error("Error sending email:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Send a test email for campaign preview
 */
export async function sendTestEmail(params: {
  testEmail: string;
  campaign: {
    subject: string;
    fromName: string;
    fromEmail: string;
    html: string;
  };
  clubSettings: {
    replyToEmail?: string | null;
  };
}): Promise<{ success: boolean; error?: string }> {
  // Generate test unsubscribe URL with special "test" token
  const testUnsubscribeUrl = generateUnsubscribeLink("test");
  
  // Inject unsubscribe link into HTML
  const htmlWithUnsubscribe = injectUnsubscribeLink(
    params.campaign.html,
    "test"
  );
  
  const result = await sendEmail({
    to: params.testEmail,
    from: params.campaign.fromEmail,
    fromName: params.campaign.fromName,
    replyTo: params.clubSettings.replyToEmail ?? undefined,
    subject: `[TEST] ${params.campaign.subject}`,
    html: htmlWithUnsubscribe,
    unsubscribeUrl: testUnsubscribeUrl,
  });

  return {
    success: result.success,
    error: result.error,
  };
}

/**
 * Generate unsubscribe link for a subscriber
 */
export function generateUnsubscribeLink(unsubscribeToken: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
  return `${baseUrl}/unsubscribe?token=${unsubscribeToken}`;
}

/**
 * Inject unsubscribe link into email HTML
 * This function finds the empty unsubscribe paragraph in the template footer and adds the link
 */
export function injectUnsubscribeLink(html: string, unsubscribeToken: string): string {
  const unsubscribeLink = generateUnsubscribeLink(unsubscribeToken);
  
  // If there's already an unsubscribe placeholder, replace it
  if (html.includes("{{unsubscribe_url}}")) {
    return html.replace(/\{\{unsubscribe_url\}\}/g, unsubscribeLink);
  }
  
  // Look for the empty footer text paragraph that would have contained the unsubscribe link
  // This is generated by the template when unsubscribeUrl is undefined
  // The template renders an empty <p> tag with the footer text style
  const emptyFooterPattern = /<p[^>]*style="[^"]*font-size:\s*12px[^"]*"[^>]*>\s*<\/p>/i;
  
  if (emptyFooterPattern.test(html)) {
    // Replace the empty paragraph with one containing the unsubscribe link
    return html.replace(
      emptyFooterPattern,
      `<p style="font-size:12px;line-height:1.5;color:#8898aa;margin-bottom:8px;margin-top:0"><a href="${unsubscribeLink}" style="color:#3b82f6;text-decoration:underline">Unsubscribe</a></p>`
    );
  }
  
  // Fallback: If the template structure has changed, append unsubscribe footer before </body>
  const footer = `
    <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e5e5; font-size: 12px; color: #666; text-align: center;">
      <p>
        <a href="${unsubscribeLink}" style="color: #3b82f6; text-decoration: underline;">Unsubscribe</a> from this mailing list.
      </p>
    </div>
  `;
  
  if (html.includes("</body>")) {
    return html.replace("</body>", `${footer}</body>`);
  }
  
  return html + footer;
}

/**
 * Send a campaign email to a subscriber
 */
export async function sendCampaignEmail(params: {
  subscriber: {
    email: string;
    name?: string | null;
    unsubscribeToken: string;
  };
  campaign: {
    subject: string;
    fromName: string;
    fromEmail: string;
    html: string;
  };
  clubSettings: {
    replyToEmail?: string | null;
  };
}): Promise<{
  success: boolean;
  messageId?: string;
  error?: string;
}> {
  // Generate unsubscribe URL
  const unsubscribeUrl = generateUnsubscribeLink(params.subscriber.unsubscribeToken);
  
  // Inject unsubscribe link
  const htmlWithUnsubscribe = injectUnsubscribeLink(
    params.campaign.html,
    params.subscriber.unsubscribeToken
  );
  
  // Personalize subject and content if subscriber has a name
  let subject = params.campaign.subject;
  let html = htmlWithUnsubscribe;
  
  if (params.subscriber.name) {
    subject = subject.replace(/\{\{name\}\}/g, params.subscriber.name);
    html = html.replace(/\{\{name\}\}/g, params.subscriber.name);
  }
  
  return await sendEmail({
    to: params.subscriber.email,
    from: params.campaign.fromEmail,
    fromName: params.campaign.fromName,
    replyTo: params.clubSettings.replyToEmail ?? undefined,
    subject,
    html,
    unsubscribeUrl,
  });
}

/**
 * Batch send emails with rate limiting
 * AWS SES has rate limits, so we need to throttle sends
 */
export async function batchSendCampaignEmails(params: {
  subscribers: Array<{
    id: string;
    email: string;
    name?: string | null;
    unsubscribeToken: string;
  }>;
  campaign: {
    subject: string;
    fromName: string;
    fromEmail: string;
    html: string;
  };
  clubSettings: {
    replyToEmail?: string | null;
  };
  onProgress?: (sent: number, total: number) => void;
  maxPerSecond?: number; // Default SES limit is 14 emails/second for most accounts
}): Promise<{
  sent: number;
  failed: number;
  results: Array<{
    subscriberId: string;
    success: boolean;
    messageId?: string;
    error?: string;
  }>;
}> {
  const maxPerSecond = params.maxPerSecond ?? 10; // Conservative default
  const delayMs = 1000 / maxPerSecond;
  
  const results: Array<{
    subscriberId: string;
    success: boolean;
    messageId?: string;
    error?: string;
  }> = [];
  
  let sent = 0;
  let failed = 0;
  
  for (let i = 0; i < params.subscribers.length; i++) {
    const subscriber = params.subscribers[i]!;
    
    const result = await sendCampaignEmail({
      subscriber,
      campaign: params.campaign,
      clubSettings: params.clubSettings,
    });
    
    results.push({
      subscriberId: subscriber.id,
      success: result.success,
      messageId: result.messageId,
      error: result.error,
    });
    
    if (result.success) {
      sent++;
    } else {
      failed++;
    }
    
    // Call progress callback
    params.onProgress?.(sent + failed, params.subscribers.length);
    
    // Rate limiting delay (except for the last email)
    if (i < params.subscribers.length - 1) {
      await new Promise(resolve => setTimeout(resolve, delayMs));
    }
  }
  
  return { sent, failed, results };
}
